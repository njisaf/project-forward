import { isObject, klona } from '@typhonjs-fvtt/runtime/util/object';

/**
 * Provides a helper class to determine the version of the Foundry platform starting a version `9`.
 *
 * Note: You must use any of these utility methods after the Foundry `init` hook.
 */
class FVTTVersion
{
   static #regexMajorVersion = /(\d+)\./;

   /**
    * Returns true when Foundry is at least the specific major version number provided.
    *
    * Note: `game` must be initialized for correct comparison; use after Foundry `init` hook.
    *
    * @param {number}   version - Major version to check against.
    *
    * @returns {boolean} Foundry version is at least the major version specified.
    */
   static isAtLeast(version)
   {
      if (globalThis.game?.version === void 0)
      {
         throw new Error(`FVTTVersion.isAtLeast error: Foundry VTT global 'game' object is not initialized.`);
      }

      if (!Number.isInteger(version) && version < 9)
      {
         throw new TypeError(`'version' is not a positive integer greater than or equals '9'.`);
      }

      return !globalThis.foundry.utils.isNewerVersion(version, globalThis.game.version);
   }

   /**
    * Returns true when Foundry is inclusively between the min / max major version numbers provided.
    *
    * @param {number}   min - Major minimum version to check against.
    *
    * @param {number}   max - Major maximum version to check against.
    *
    * @returns {boolean} Foundry version is at least the major version specified.
    */
   static isBetween(min, max)
   {
      if (globalThis.game?.version === void 0)
      {
         throw new Error(`FVTTVersion.isBetween error: Foundry VTT global 'game' object is not initialized.`);
      }

      if (!Number.isInteger(min) && min < 9)
      {
         throw new TypeError(
          `FVTTVersion.isBetween error: 'min' is not a positive integer greater than or equals '9'.`);
      }

      if (!Number.isInteger(max) && max < 9)
      {
         throw new TypeError(
          `FVTTVersion.isBetween error: 'max' is not a positive integer greater than or equals '9'.`);
      }

      if (min > max)
      {
         throw new TypeError(`FVTTVersion.isBetween error: 'min' is greater than 'max'.`);
      }

      const match = this.#regexMajorVersion.exec(globalThis.game.version);
      if (!match)
      {
         throw new Error(`FVTTVersion.isBetween error: Could not parse 'globalThis.game.version'.`);
      }

      const version = parseInt(match[1], 10);

      return version >= min && version <= max;
   }
}

/**
 * Loads FVTT core fonts supporting `FontConfig` on Foundry v10+.
 *
 * Note: This class contains code modified from Foundry VTT core client code. There are only so many ways to process
 * core Foundry data structures correctly.
 */
class FontManager
{
   /**
    * Collect all the font definitions and combine them.
    *
    * @returns { {[key: string]: fvtt.FontFamilyDefinition}[] } Core font definitions.
    */
   static getCoreDefinitions()
   {
      /** @type { {[key: string]: fvtt.FontFamilyDefinition}[] } */
      const fonts = [];

      if (FVTTVersion.isAtLeast(11))
      {
         if (isObject(globalThis.CONFIG?.fontDefinitions))
         {
            fonts.push(klona(globalThis.CONFIG.fontDefinitions));
         }

         const coreFonts = globalThis.game?.settings.get('core', 'fonts');

         if (Array.isArray(coreFonts))
         {
            fonts.push(klona(coreFonts));
         }
      }

      FontManager.removeDuplicateDefinitions(fonts);

      return fonts;
   }

   /**
    * Load a font definition.
    *
    * @param {string}               fontSpecification - The font specification.
    *
    * @param {string}               family - The font family name (case-sensitive).
    *
    * @param {fvtt.FontFamilyDefinition} definition - The font family definition.
    *
    * @param {Document}             document - Target Document to load font into.
    *
    * @returns {Promise<boolean>} Returns true if the font was successfully loaded.
    */
   static async #loadFont(fontSpecification, family, definition, document)
   {
      try
      {
         for (const fontEntry of definition.fonts)
         {
            // Collect URLs from FontDefinition.
            const urls = fontEntry.urls.map((url) => `url("${url}")`).join(', ');

            // Note: 'font' contains 'FontFaceDescriptors' data.
            const fontFace = new FontFace(family, urls, fontEntry);
            await fontFace.load();

            document.fonts.add(fontFace);
         }

         await document.fonts.load(fontSpecification);
      }
      catch (err)
      {
         console.warn(`Font family "${family}" failed to load: `, err);
         return false;
      }

      if (!document.fonts.check(fontSpecification))
      {
         console.warn(`Font family "${family}" failed to load.`);
         return false;
      }

      return true;
   }

   /**
    * Ensure that fonts have loaded and are ready for use.
    * Enforce a maximum timeout in milliseconds.
    * Proceed after that point even if fonts are not yet available.
    *
    * @param {object} [opts] - Optional parameters.
    *
    * @param {number} [opts.ms=4500] - The maximum time to spend loading fonts before proceeding.
    *
    * @param {Document} [opts.document] - The target document to load the fonts into.
    *
    * @param {boolean} [opts.editor=true] - When true verifies the `editor` field of {@link FontFamilyDefinition}.
    *
    * @param {(
    *    {[key: string]: fvtt.FontFamilyDefinition}[] |
    *    {[key: string]: fvtt.FontFamilyDefinition}
    * )} [opts.fonts] - A custom set of font family definitions to load. If not defined the core font family definitions
    *    are loaded.
    *
    * @returns {Promise<void>}
    */
   static async loadFonts({ ms = 4500, document = globalThis.document, editor = true, fonts } = {})
   {
      // TODO sanity checks

      const allFonts = fonts ? Array.isArray(fonts) ? fonts : [fonts] : this.getCoreDefinitions();

      const promises = [];

      for (const definitions of allFonts)
      {
         if (isObject(definitions))
         {
            for (const [family, definition] of Object.entries(definitions))
            {
               // Don't load a font that is not marked to be used in the editor.
               if (editor && (typeof definition.editor !== 'boolean' || !definition.editor)) { continue; }

               const fontSpecification = `1rem "${family}"`;

               // TODO: If there is a better / reliable way to check if a font is already loaded then implement below.
               // `document.fonts.check` doesn't quite work for the intended purpose.
               // Early out if the font is already loaded.
               // if (document.fonts.check(fontSpecification)) { continue; }

               promises.push(this.#loadFont(fontSpecification, family, definition, document));
            }
         }
      }

      const timeout = new Promise((resolve) => setTimeout(resolve, ms));
      const ready = Promise.allSettled(promises).then(() => document.fonts.ready);

      return Promise.race([ready, timeout]);
   }

   /**
    * Removes duplicate font definitions.
    *
    * @param { {[key: string]: fvtt.FontFamilyDefinition}[] }  fonts - An array of FontFamilyDefinition objects
    *        to process.
    *
    * @returns { {[key: string]: fvtt.FontFamilyDefinition}[] } Filtered font definitions.
    */
   static removeDuplicateDefinitions(fonts)
   {
      if (!Array.isArray(fonts))
      {
         throw new TypeError(`FontManager.removeDuplicateDefinitions error: 'fonts' is not an array.`);
      }

      const familySet = new Set();

      for (const definitions of fonts)
      {
         if (!isObject(definitions))
         {
            throw new TypeError(`FontManager.removeDuplicateDefinitions error: 'definitions' is not an object.`);
         }

         for (const family of Object.keys(definitions))
         {
            // Remove duplicate from current definitions set.
            if (familySet.has(family))
            {
               delete definitions[family];
            }
            else
            {
               familySet.add(family);
            }
         }
      }

      return fonts;
   }
}

/**
 * Parses the core Foundry style sheet creating an indexed object of properties by selector.
 */
class FoundryStyles
{
   static #sheet = void 0;

   /** @type {Map<string, {[key: string]: string}>} */
   static #sheetMap = new Map();

   static #initialized = false;

   /**
    * Called once on initialization / first usage. Parses the core foundry style sheet.
    */
   static #initialize()
   {
      this.#initialized = true;

      const styleSheets = Array.from(document.styleSheets).filter((entry) => entry.href !== null);

      let sheet;

      const foundryStyleSheet = globalThis.foundry.utils.getRoute('/css/style.css');

      // Find the core Foundry stylesheet.
      for (const styleSheet of styleSheets)
      {
         let url;

         try
         {
            url = new URL(styleSheet.href);
         }
         catch (err) { continue; }

         if (typeof url.pathname === 'string' && url.pathname === foundryStyleSheet)
         {
            this.#sheet = sheet = styleSheet;
            break;
         }
      }

      // Quit now if the Foundry style sheet was not found.
      if (!sheet) { return; }

      // Parse each CSSStyleRule and build the map of selectors to parsed properties.
      for (const rule of sheet.cssRules)
      {
         if (!(rule instanceof CSSStyleRule)) { continue; }

         const obj = {};

         // Parse `cssText` into an object of properties & values.
         for (const entry of rule.style.cssText.split(';'))
         {
            const parts = entry.split(':');

            // Sanity check.
            if (parts.length < 2) { continue; }

            obj[parts[0].trim()] = parts[1].trim();
         }

         this.#sheetMap.set(rule.selectorText, obj);
      }
   }

   /**
    * Gets the properties object associated with the selector. Try and use a direct match otherwise all keys
    * are iterated to find a selector string that includes the `selector`.
    *
    * @param {string}   selector - Selector to find.
    *
    * @returns { {[key: string]: string} } Properties object.
    */
   static getProperties(selector)
   {
      if (!this.#initialized) { this.#initialize(); }

      // If there is a direct selector match then return a value immediately.
      if (this.#sheetMap.has(selector))
      {
         return this.#sheetMap.get(selector);
      }

      for (const key of this.#sheetMap.keys())
      {
         if (key.includes(selector)) { return this.#sheetMap.get(key); }
      }

      return void 0;
   }

   /**
    * Gets a specific property value from the given `selector` and `property` key. Try and use a direct selector
    * match otherwise all keys are iterated to find a selector string that includes `selector`.
    *
    * @param {string}   selector - Selector to find.
    *
    * @param {string}   property - Specific property to locate.
    *
    * @returns {string|undefined} Property value.
    */
   static getProperty(selector, property)
   {
      if (!this.#initialized) { this.#initialize(); }

      // If there is a direct selector match then return a value immediately.
      if (this.#sheetMap.has(selector))
      {
         const data = this.#sheetMap.get(selector);
         return isObject(data) && property in data ? data[property] : void 0;
      }

      for (const key of this.#sheetMap.keys())
      {
         if (key.includes(selector))
         {
            const data = this.#sheetMap.get(key);
            if (isObject(data) && property in data) { return data[property]; }
         }
      }

      return void 0;
   }
}

export { FVTTVersion, FontManager, FoundryStyles };
//# sourceMappingURL=index.js.map
