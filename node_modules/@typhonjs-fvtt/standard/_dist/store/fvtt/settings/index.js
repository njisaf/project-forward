import { writable } from 'svelte/store';
import { TJSDialog } from '@typhonjs-fvtt/runtime/svelte/application';
import { TJSSvelte } from '@typhonjs-fvtt/runtime/svelte/util';
import { TJSGameSettings } from '@typhonjs-fvtt/runtime/svelte/store/fvtt/settings';
import { localize } from '@typhonjs-fvtt/runtime/util/i18n';
import { isObject, isIterable } from '@typhonjs-fvtt/runtime/util/object';
import { ripple, rippleFocus } from '@typhonjs-fvtt/standard/action/animate/composable';
import { getFormat } from '@typhonjs-fvtt/runtime/data/color/colord';
import { propertyStore } from '@typhonjs-fvtt/runtime/svelte/store/writable-derived';
import { TJSStyleManager } from '@typhonjs-fvtt/runtime/util/dom/style';

/**
 * Extends {@link TJSGameSettings} with UI control for working with `TJSSettingsEdit` and `TJSSettingsSwap`
 * components. Instead of extending `TJSGameSettings` simply extend `TJSGameSettingsWithUI` instead when creating
 * reactive game settings that utilize the above components.
 */
class TJSGameSettingsWithUI extends TJSGameSettings
{
   /** @type {import('./types').UIControl} */
   #uiControl;

   /**
    * Creates the TJSGameSettingsWithUI instance.
    *
    * @param {string}   namespace - The namespace for all settings.
    */
   constructor(namespace)
   {
      super(namespace);

      this.#uiControl = new UIControl(this);
   }

   /**
    * @returns {import('./types').UIControl} The associated UIControl.
    */
   get uiControl()
   {
      return this.#uiControl;
   }
}

/**
 * Controls preparation and processing of registered game settings w/ TJSGameSettingsUI. Game settings are parsed
 * for UI display by TJSSettingsEdit. The store `showSettings` is utilized in TJSSettingsSwap component to provide
 * an easy way to flip between settings component or any main slotted component.
 */
class UIControl
{
   /** @type {import('./types').TJSSettingsCustomSection[]} */
   #sections = [];

   /** @type {import('./').TJSGameSettings} */
   #settings;

   /** @type {boolean} */
   #showSettings = false;

   /** @type {Function} */
   #showSettingsSet;

   /** @type {{showSettings: import('svelte/store').Readable<boolean>}} */
   #stores;

   /**
    * @param {import('./').TJSGameSettings}   settings -
    */
   constructor(settings)
   {
      this.#settings = settings;

      const showSettings = writable(this.#showSettings);
      this.#showSettingsSet = showSettings.set;

      this.#stores = {
         showSettings: { subscribe: showSettings.subscribe }
      };

      Object.freeze(this.#stores);
   }

   /**
    * @returns {boolean} Current `showSettings` state.
    */
   get showSettings()
   {
      return this.#showSettings;
   }

   /**
    * @returns {{ showSettings: import('svelte/store').Readable<boolean> }} Returns the managed stores.
    */
   get stores()
   {
      return this.#stores;
   }

   /**
    * Sets current `showSettings` state.
    *
    * @param {boolean}  showSettings - New `showSettings` state.
    */
   set showSettings(showSettings)
   {
      this.#showSettings = showSettings;
      this.#showSettingsSet(this.#showSettings);
   }

   /**
    * Adds a custom section / folder defined by the provided TJSSettingsCustomSection options object.
    *
    * @param {import('./types').TJSSettingsCustomSection} options - The configuration object for the custom section.
    */
   addSection(options)
   {
      if (!isObject(options)) { throw new TypeError(`'options' is not an object.`); }

      if (!TJSSvelte.util.isComponent(options.class))
      {
         throw new TypeError(`'options.class' is not a Svelte component.`);
      }

      if (options.props !== void 0 && !isObject(options.props))
      {
         throw new TypeError(`'options.props' is not an object.`);
      }

      if (options.folder !== void 0)
      {
         const folder = options.folder;

         if (typeof folder !== 'string' && !isObject(folder))
         {
            throw new TypeError(`'options.folder' is not a string or object.`);
         }

         if (isObject(folder))
         {
            if (typeof folder.label !== 'string') { throw new TypeError(`'options.folder.label' is not a string.`); }

            // Validate custom component set as folder summary end.
            if (folder.summaryEnd !== void 0)
            {
               if (!isObject(folder.summaryEnd))
               {
                  throw new TypeError(`'options.folder.summaryEnd' is not an object.`);
               }

               if (!TJSSvelte.util.isComponent(folder.summaryEnd.class))
               {
                  throw new TypeError(`'options.folder.summaryEnd.class' is not a Svelte component.`);
               }

               if (folder.summaryEnd.props !== void 0 && !isObject(folder.summaryEnd.props))
               {
                  throw new TypeError(`'options.folder.summaryEnd.props' is not an object.`);
               }
            }

            // Validate that folder inline styles is an object.
            if (folder.styles !== void 0 && !isObject(folder.styles))
            {
               throw new TypeError(`'options.folder.styles' is not an object.`);
            }
         }
      }

      // Validate that section inline styles is an object.
      if (options.styles !== void 0 && !isObject(options.styles))
      {
         throw new TypeError(`'options.styles' is not an object.`);
      }

      this.#sections.push(options);
   }

   /**
    * Creates the UISettingsData object by parsing stored settings in
    *
    * @param {import('./types').TJSSettingsCreateOptions} [options] - Optional parameters.
    *
    * @returns {import('./types').TJSSettingsUIData} Parsed UI settings data.
    */
   create(options)
   {
      const settings = this.#parseSettings(options);
      const destroy = () => this.#destroy(settings);

      return {
         ...settings,
         destroy
      };
   }

   /**
    * Destroy callback. Checks for any `requiresReload` parameter in each setting comparing against initial value
    * when `settings` is created and current value. If there is a difference then show a modal dialog asking the user
    * if they want to reload for those settings to take effect.
    *
    * @param {import('./types').TJSSettingsUIData}   settings - The UI data object initiated w/ `create`.
    */
   #destroy(settings)
   {
      let requiresClientReload = false;
      let requiresWorldReload = false;

      if (Array.isArray(settings.topLevel))
      {
         for (const setting of settings.topLevel)
         {
            const current = globalThis.game.settings.get(setting.namespace, setting.key);
            if (current === setting.initialValue) { continue; }

            requiresClientReload ||= (setting.scope === 'client') && setting.requiresReload;
            requiresWorldReload ||= (setting.scope === 'world') && setting.requiresReload;
         }
      }

      if (Array.isArray(settings.folders))
      {
         for (const folder of settings.folders)
         {
            if (Array.isArray(folder.settings))
            {
               for (const setting of folder.settings)
               {
                  const current = globalThis.game.settings.get(setting.namespace, setting.key);
                  if (current === setting.initialValue) { continue; }

                  requiresClientReload ||= (setting.scope === 'client') && setting.requiresReload;
                  requiresWorldReload ||= (setting.scope === 'world') && setting.requiresReload;
               }
            }
         }
      }

      if (requiresClientReload || requiresWorldReload) { this.#reloadConfirm({ world: requiresWorldReload }); }

      this.#showSettings = false;
      this.#showSettingsSet(this.#showSettings);
   }

   /**
    * @param {import('./types').TJSSettingsCreateOptions} [options] - Optional parameters.
    *
    * @returns {import('./types').TJSSettingsUIData} Parsed UI settings data.
    */
   #parseSettings({ efx = 'ripple', storage } = {})
   {
      const namespace = this.#settings.namespace;

      if (storage && typeof namespace !== 'string')
      {
         console.warn(
          `TJSGameSettings warning: 'options.storage' defined, but 'namespace' not defined in TJSGameSettings.`);
      }

      const hasStorage = storage && typeof namespace === 'string';

      const uiSettings = [];

      const canConfigure = globalThis.game.user.can('SETTINGS_MODIFY');

      for (const setting of this.#settings.data())
      {
         if (!setting.config || (!canConfigure && (setting.scope !== 'client'))) { continue; }

         let options;

         if (isObject(setting.choices))
         {
            options = Object.entries(setting.choices).map((entry) => ({ value: entry[0], label: localize(entry[1]) }));
         }

         let range;
         if (isObject(setting.range))
         {
            range = {};

            // TODO Better error messages.
            // Verify range data.
            if (typeof setting.range.min !== 'number') { throw new TypeError(`Setting 'range.min' is not a number.`); }
            if (typeof setting.range.max !== 'number') { throw new TypeError(`Setting 'range.max' is not a number.`); }
            if (setting.range.step !== void 0 && typeof setting.range.step !== 'number')
            {
               throw new TypeError(`Setting 'range.step' is not a number.`);
            }

            range.min = setting.range.min;
            range.max = setting.range.max;
            range.step = setting.range.step ? setting.range.step : 1;
         }

         // Default to `String` if no type is provided.
         const type = setting.type instanceof Function ? setting.type.name : 'String';

         // Only configure file picker if setting type is a string.
         let filePicker;
         if (type === 'String')
         {
            filePicker = setting.filePicker === true ? 'any' : setting.filePicker;
         }

         let buttonData;
         if (filePicker)
         {
            buttonData = {
               icon: 'fas fa-file-import fa-fw',
               efx: efx === 'ripple' ? ripple() : void 0,
               title: 'FILES.BrowseTooltip',
               styles: { 'margin-left': '0.25em' }
            };
         }

         const store = this.#settings.getStore(setting.key);

         let selectData;

         /** @type {string} */
         let componentType = 'text';

         if (setting.type === Boolean)
         {
            componentType = 'checkbox';
         }
         else if (options !== void 0)
         {
            componentType = 'select';

            selectData = {
               store,
               efx: efx === 'ripple' ? rippleFocus() : void 0,
               type: componentType,
               options
            };
         }
         else if (setting.type === Number)
         {
            componentType = isObject(setting.range) ? 'range' : 'number';
         }

         let inputData;
         if (componentType === 'text' || componentType === 'number')
         {
            inputData = {
               store,
               efx: efx === 'ripple' ? rippleFocus() : void 0,
               type: componentType
            };
         }

         uiSettings.push({
            id: `${setting.namespace}.${setting.key}`,
            namespace: setting.namespace,
            folder: setting.folder,
            key: setting.key,
            name: localize(setting.name),
            hint: localize(setting.hint),
            type,
            componentType,
            filePicker,
            range,
            store,
            initialValue: globalThis.game.settings.get(setting.namespace, setting.key),
            scope: setting.scope,
            requiresReload: typeof setting.requiresReload === 'boolean' ? setting.requiresReload : false,
            buttonData,
            inputData,
            selectData
         });
      }

      // If storage is available then create a key otherwise create a dummy store, so `applyScrolltop` works.
      const storeScrollbar = hasStorage ? storage.getStore(`${namespace}-settings-scrollbar`) : writable(0);

      const topLevel = [];

      const folderData = {};

      // Sort into folders
      for (const setting of uiSettings)
      {
         if (typeof setting.folder === 'string')
         {
            const folderName = localize(setting.folder);

            // Create folder array if one doesn't exist already.
            if (!Array.isArray(folderData[folderName])) { folderData[folderName] = []; }
            folderData[folderName].push(setting);
         }
         else // Add to 'toplevel' settings
         {
            topLevel.push(setting);
         }
      }

      // Convert folderData object to array.
      const folders = Object.entries(folderData).map((entry) =>
      {
         return {
            label: entry[0],
            store: hasStorage ? storage.getStore(`${namespace}-settings-folder-${entry[0]}`) : void 0,
            settings: entry[1],
         };
      });

      const sections = [];

      // Parse custom component sections
      for (const section of this.#sections)
      {
         const parsedSection = {
            class: section.class,
            props: section.props,
            styles: section.styles
         };

         if (typeof section.folder === 'string')
         {
            const label = localize(section.folder);

            parsedSection.folder = {
               label,
               store: hasStorage ? storage.getStore(`${namespace}-settings-folder-${label}`) : void 0
            };
         }
         else if (isObject(section.folder))
         {
            const label = localize(section.folder.label);

            parsedSection.folder = {
               label,
               store: hasStorage ? storage.getStore(`${namespace}-settings-folder-${label}`) : void 0,
               summaryEnd: section.folder.summaryEnd,
               styles: section.folder.styles
            };
         }

         sections.push(parsedSection);
      }

      return {
         storeScrollbar,
         topLevel,
         folders,
         sections
      };
   }

   async #reloadConfirm({ world = false } = {})
   {
      let title = localize('SETTINGS.ReloadPromptTitle');
      let label = localize('SETTINGS.ReloadPromptBody');

      // Foundry v9 doesn't have the reload lang keys, so substitute just for English translation.
      // TODO: FOUNDRY_V9 - remove when support for v9 is dropped.
      title = title !== 'SETTINGS.ReloadPromptTitle' ? title : 'Reload Application?';
      label = label !== 'SETTINGS.ReloadPromptBody' ? label :
       'Some of the changed settings require a reload of the application to take effect. Would you like to reload now?';

      const reload = await TJSDialog.confirm({
         modal: true,
         draggable: false,
         title,
         content: `<p>${label}</p>`
      });

      if (!reload) { return; }

      // Reload all connected clients. Note: Foundry v9 might not support this event.
      if (world && globalThis.game.user.isGM) { globalThis.game.socket.emit('reload'); }

      // Reload locally.
      window.location.reload();
   }

   /**
    * Convenience method to swap `showSettings`.
    *
    * @returns {boolean} New `showSettings` state.
    */
   swapShowSettings()
   {
      this.#showSettings = !this.#showSettings;
      this.#showSettingsSet(this.#showSettings);
      return this.#showSettings;
   }
}

class DataValidator
{
   /**
    * This regex tests for correct CSS variable names according to the CSS specification.
    *
    * @type {RegExp}
    *
    * @see https://www.w3.org/TR/css-variables-1/#defining-variables
    * @see https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
    */
   static #REGEX_CSS_VAR_NAME =
    /--(?:[_a-zA-Z\u00A0-\uFFFF]|\\[0-9a-fA-F]{1,6})(?:[\w\u00A0-\uFFFF-]|\\[0-9a-fA-F]{1,6})*/;

   static #SET_TYPES = new Set(['color']);

   /**
    * Parses and verifies a component entry.
    *
    * @param {import('./TJSThemeStore').TJSThemeStoreComponent} entry - A component entry.
    *
    * @param {number}   cntr - Current component entry counter.
    *
    * @returns {object} Parsed and verified component entry.
    */
   static componentEntry(entry, cntr)
   {
      const result = Object.assign({}, entry);

      if (!isObject(entry))
      {
         throw new TypeError(`TJSThemeStore initialize error: data[${cntr}] entry is not an object.`);
      }

      if (typeof entry.label !== 'string')
      {
         throw new Error(
          `TJSThemeStore initialize error: data[${cntr}] 'entry.label' is not a string.`);
      }

      if (typeof entry.type !== 'string')
      {
         throw new Error(
          `TJSThemeStore initialize error: data[${cntr}] 'entry.type' is not a string.`);
      }

      if (!this.#SET_TYPES.has(entry.type))
      {
         throw new Error(`TJSThemeStore initialize error: data[${cntr}] 'entry.type' unknown.`);
      }

      if (entry.var !== void 0 && typeof entry.var !== 'string')
      {
         throw new TypeError(`TJSThemeStore initialize error: data[${cntr}] 'entry.var' is not a string.`);
      }

      // Handle common data for CSS variable entries.
      if (typeof entry.var === 'string')
      {
         // Test for valid CSS variable name
         if (!this.#REGEX_CSS_VAR_NAME.test(entry.var))
         {
            throw new Error(
             `TJSThemeStore initialize error: data[${cntr}] 'entry.var' is not a valid CSS variable name.`);
         }

         if (typeof entry.default !== 'string')
         {
            throw new TypeError(`TJSThemeStore initialize error: data[${cntr}] 'entry.default' is not a string.`);
         }
      }

      switch (entry.type)
      {
         case 'color':
         {
            // Verify that default value is a supported color format.
            const format = getFormat(entry.default);
            if (!format)
            {
               throw new Error(`TJSThemeStore initialize error: data[${cntr}] 'entry.default' unknown color format.`);
            }

            // Add the color format to entry result data.
            result.format = format;
            break;
         }
      }

      return result;
   }
}

/**
 * A utility class to work with semantic versioning.
 */
class SemVer
{
   /**
    * Regular expression to parse a semantic version string capturing: major, minor, patch, prerelease, and build
    * metadata segments.
    *
    * @type {RegExp}
    */
   static #REGEX_SEMVER = /^(\d+)\.(\d+)\.(\d+)(?:-([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?(?:\+([0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*))?$/;

   /**
    * Parses a semantic version string and returns a semantic version data object.
    *
    * @param {string}   semver - The semantic version string to parse.
    *
    * @param {object}   [options] - Optional parameters
    *
    * @param {boolean}  [options.exceptions=false] - Throw exception on parse failure.
    *
    * @returns {SemVerData} The parsed semantic version object.
    * @throws {Error} If the input string is not a valid semantic version string.
    */
   static parseSemVer(semver, { exceptions = false } = {})
   {
      if (typeof semver !== 'string') { throw new TypeError(`'semver' is not a string.`); }

      const matches = semver.match(this.#REGEX_SEMVER);

      if (!matches)
      {
         if (exceptions)
         {
            throw new Error(`Invalid semantic versioning string: '${semver}'`);
         }
         else
         {
            return void 0;
         }
      }

      return {
         major: typeof matches?.[1] === 'string' !== void 0 ? parseInt(matches[1], 10) : 0,
         minor: typeof matches?.[2] === 'string' ? parseInt(matches[2], 10) : 0,
         patch: typeof matches?.[3] === 'string' ? parseInt(matches[3], 10) : 0,
         prerelease: typeof matches?.[4] === 'string' ? matches[4] : '',
         build: typeof matches?.[5] === 'string' ? matches[5] : ''
      };
   }

   /**
    * Compares two semantic version strings and returns a comparison result.
    *
    * @param {string} a - The first semantic version string.
    *
    * @param {string} b - The second semantic version string.
    *
    * @returns {number} 1 if a is greater than b, -1 if a is less than b, and 0 if a and b are equal.
    */
   static compareSemVerString(a, b)
   {
      return this.compareSemVerData(this.parseSemVer(a, { exceptions: true }),
       this.parseSemVer(b, { exceptions: true }));
   }

   /**
    * Compares two parsed semantic version objects and returns a comparison result.
    *
    * @param {SemVerData} a - The first parsed semantic version object.
    *
    * @param {SemVerData} b - The second parsed semantic version object.
    *
    * @returns {number} 1 if a is greater than b, -1 if a is less than b, and 0 if a and b are equal.
    */
   static compareSemVerData(a, b)
   {
      const majorA = a.major;
      const majorB = b.major;
      const minorA = a.minor;
      const minorB = b.minor;
      const patchA = a.patch;
      const patchB = b.patch;

      if (majorA > majorB) { return 1; }
      if (majorA < majorB) { return -1; }

      if (minorA > minorB) { return 1; }
      if (minorA < minorB) { return -1; }

      if (patchA > patchB) { return 1; }
      if (patchA < patchB) { return -1; }

      const prereleaseA = a.prerelease ?? '';
      const prereleaseB = b.prerelease ?? '';

      if (prereleaseA && !prereleaseB) { return -1; }
      if (!prereleaseA && prereleaseB) { return 1; }

      if (prereleaseA && prereleaseB)
      {
         const partsA = prereleaseA.split('.');
         const partsB = prereleaseB.split('.');
         const len = Math.min(partsA.length, partsB.length);

         for (let i = 0; i < len; i++)
         {
            const partA = parseInt(partsA[i], 10);
            const partB = parseInt(partsB[i], 10);

            if (!isNaN(partA) && isNaN(partB)) { return -1; }
            if (isNaN(partA) && !isNaN(partB)) { return 1; }

            if (partA > partB) { return 1; }
            if (partA < partB) { return -1; }

            if (isNaN(partA) && isNaN(partB))
            {
               if (partsA[i] > partsB[i]) { return 1; }
               if (partsA[i] < partsB[i]) { return -1; }
            }
         }

         if (partsA.length > partsB.length) { return 1; }
         if (partsA.length < partsB.length) { return -1; }
      }

      return 0;
   }
}

/**
 * @typedef {object} SemVerData
 *
 * @property {number} major The major version number as a string.
 *
 * @property {number} minor The minor version number as a string.
 *
 * @property {number} patch The patch version number as a string.
 *
 * @property {string} prerelease The prerelease version identifier as a string, or an empty string if not present.
 *
 * @property {string} build The build metadata identifier as a string, or an empty string if not present.
 */

/**
 * Must be constructed from a TJSGameSettings instance `init` / initialize method called from the `ready` Foundry VTT
 * hook.
 */
class TJSThemeStore
{
   /** @type {object[]} */
   #components;

   /** @type {{}} */
   #data = {};

   #defaultThemeData;

   #initialThemeData;

   #settingsStoreHandler;

   /**
    * @type { {[key: string]: import('svelte/store').Writable<string|null>} }
    */
   #stores = {};

   /**
    * @type {TJSStyleManager}
    */
   #styleManager;

   /**
    * Stores the subscribers.
    *
    * @type {import('svelte/store').Subscriber<{ [key: string]: object }>[]}
    */
   #subscriptions = [];

   /**
    * Stores all CSS variable keys.
    *
    * @type {string[]}
    */
   #vars;

   /**
    * @type {import('./DataValidator').SemVerData}
    */
   #version;

   /**
    * @param {TJSThemeStoreOptions} options - Options
    */
   constructor(options)
   {
      if (!isObject(options)) { throw new TypeError(`'options' is not an object.`); }

      if (typeof options.namespace !== 'string') { throw new TypeError(`'namespace' attribute is not a string.`); }

      if (typeof options.key !== 'string') { throw new TypeError(`'key' attribute is not a string.`); }

      if (!(options.gameSettings instanceof TJSGameSettings))
      {
         throw new TypeError(`'gameSettings' attribute is not an instance of TJSGameSettings.`);
      }

      if (!(options.styleManager instanceof TJSStyleManager))
      {
         throw new TypeError(`'styleManager' attribute is not an instance of TJSStyleManager.`);
      }

      if (!isObject(options.config)) { throw new TypeError(`'config' attribute is not an object. `); }

      if (typeof options.config.version !== 'string')
      {
         throw new TypeError(`'config.version' attribute is not a string`);
      }

      this.#version = SemVer.parseSemVer(options.config.version);

      if (!isObject(this.#version))
      {
         throw new Error(`'config.version' attribute is not a valid semantic version string.`);
      }

      if (!isIterable(options.config.components))
      {
         throw new TypeError(`'config.components' attribute is not an iterable list. `);
      }

      this.#styleManager = options.styleManager;

      this.#initialize(options);
   }

   /**
    * @returns { {[key: string]: import('svelte/store').Writable<string|null>} } All stores.
    */
   get stores()
   {
      return this.#stores;
   }

   /**
    * Parse `options.config` and initialize game setting for theme data.
    *
    * @param {TJSThemeStoreOptions}   options -
    */
   #initialize(options)
   {
      this.#components = [];
      this.#vars = [];

      this.#defaultThemeData = {};
      this.#initialThemeData = Object.assign({}, this.#defaultThemeData);

      let cntr = 0;

      // Process component / vars data.
      for (let entry of options.config.components)
      {
         // Validate entry, but also adds additional information based on data types; IE `format` for `color`.
         entry = DataValidator.componentEntry(entry, cntr);

         // Add var key if defined.
         if (typeof entry.var === 'string')
         {
            const key = entry.var;

            this.#vars.push(key);
            this.#stores[key] = propertyStore(this, key);
            this.#components.push(Object.assign({}, entry, { store: this.#stores[key] }));
            this.#defaultThemeData[key] = entry.default;
         }
         else
         {
            this.#components.push(Object.assign({}, entry));
         }

         cntr++;
      }

      // Create a store for TJSThemeEditor of all component data / definitions.
      this.#stores.components = writable(this.#components);

      // Set initial data to default here just in case the game setting entry is invalid upon registration / IE null.
      this.#initialThemeData = Object.assign({}, this.#defaultThemeData);

      this.#settingsStoreHandler = options.gameSettings.register({
         namespace: options.namespace,
         key: options.key,
         store: this,
         options: {
            scope: 'world',
            config: false,
            default: Object.assign({}, this.#defaultThemeData),
            type: Object
         }
      });

      // Retrieve existing data from stored word setting.
      this.#initialThemeData = game.settings.get(options.namespace, options.key);

      // Validate initial theme data and set to default if it fails to validate.
      if (!this.#validateThemeData(this.#initialThemeData, false))
      {
         console.warn(
          `TJSThemeStore warning: Initial theme data invalid. Setting to default data.`);

         this.#initialThemeData = Object.assign({}, this.#defaultThemeData);

         this.set(Object.assign({}, this.#initialThemeData));
      }
   }

   /**
    * Sets the theme store with new data.
    *
    * @param {object}   themeData -
    *
    * @returns {TJSThemeStore} This theme store instance.
    */
   set(themeData)
   {
      if (!this.#validateThemeData(themeData))
      {
         themeData = Object.assign({}, this.#initialThemeData);
      }

      for (const key of this.#vars)
      {
         if (key in themeData)
         {
            const keyData = themeData[key];

            this.#data[key] = keyData;
            this.#styleManager.setProperty(key, keyData);
         }
      }

      this.#updateSubscribers();

      return this;
   }

   /**
    * Validates the given theme data object ensuring that all parameters are found and are correct HSVA values.
    *
    * @param {object}   themeData -
    *
    * @param {boolean}  warn - When true post warning message.
    *
    * @returns {boolean} Validation status.
    */
   #validateThemeData(themeData, warn = true)
   {
      if (!isObject(themeData))
      {
         if (warn)
         {
            console.warn(`TJSThemeStore warning: 'theme' data is not an object resetting to initial data.`);
         }

         return false;
      }

      for (const key of this.#vars)
      {
         const data = themeData[key];

         if (getFormat(data) !== 'hsl')
         {
            if (warn)
            {
               console.warn(`TJSThemeStore warning: data for property '${
                key}' is not a HSL color string. Resetting to initial data.`);
            }

            return false;
         }
      }

      return true;
   }

   // ------------

   /**
    * Updates all subscribers
    */
   #updateSubscribers()
   {
      const data = Object.assign({}, this.#data);

      // Early out if there are no subscribers.
      if (this.#subscriptions.length > 0)
      {
         for (let cntr = 0; cntr < this.#subscriptions.length; cntr++) { this.#subscriptions[cntr](data); }
      }
   }

   /**
    * @param {import('svelte/store').Subscriber<{ [key: string]: object }>} handler - Callback function that is invoked on
    * update / changes. Receives copy of the theme data.
    *
    * @returns {import('svelte/store').Unsubscriber} Unsubscribe function.
    */
   subscribe(handler)
   {
      this.#subscriptions.push(handler); // add handler to the array of subscribers

      handler(Object.assign({}, this.#data));                     // call handler with current value

      // Return unsubscribe function.
      return () =>
      {
         const index = this.#subscriptions.findIndex((sub) => sub === handler);
         if (index >= 0) { this.#subscriptions.splice(index, 1); }
      };
   }
}

/**
 * @typedef {object} TJSThemeStoreConfig
 *
 * @property {string} version A semantic version string.
 *
 * @property {Iterable<TJSThemeStoreComponent>} components An iterable list of theme store component data.
 */

/**
 * @typedef {object} TJSThemeStoreComponent
 *
 * @property {string} type Type of component / variable.
 *
 * @property {string} [default] An optional default value for a CSS variable.
 *
 * @property {string} [label] An optional label for any variable / setting related component.
 *
 * @property {string} [var] A CSS variable name.
 */

/**
 * @typedef {object} TJSThemeStoreOptions
 *
 * @property {string} namespace The world setting namespace.
 *
 * @property {string} key The world setting key.
 *
 * @property {TJSGameSettings} gameSettings An associated TJSGameSettings instance.
 *
 * @property {TJSStyleManager} styleManager An associated TJSStyleManager instance to manipulate CSS variables.
 *
 * @property {TJSThemeStoreConfig} config Data defining CSS theme store components and variables.
 */

export { TJSGameSettingsWithUI, TJSThemeStore };
//# sourceMappingURL=index.js.map
